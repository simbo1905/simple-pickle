NFP PERFORMANCE PROFILING REPORT
=================================

Date: 2025-05-31
Report ID: 1
Analyst: Claude Code
Issue: Write Performance Regression

EXECUTIVE SUMMARY
================
NFP primitive write performance is 10x slower than JDK serialization (126k vs 1.3M ops/s).
JFR profiling reveals that reflection work is happening on the hot path during every 
serialization operation instead of being cached during pickler construction.

PROBLEM DESCRIPTION
==================
Benchmark: PrimitiveBenchmark (8 primitive fields in record)
Performance Gap: NFP 125,664 ops/s vs JDK 1,334,092 ops/s (10.6x slower)
Data: AllPrimitives(boolean, byte, short, char, int, long, float, double)
Buffer Size: 256 bytes (fair allocation off hot path)

PROFILING METHODOLOGY  
====================
1. Created WritePathProfiler.java - focused reproducer isolating write operations
2. Ran with JFR: java -XX:StartFlightRecording:filename=write-profile.jfr WritePathProfiler
3. Analyzed with: jfr view hot-methods / allocation-by-site write-profile.jfr
4. Profiled 1,095,729 write operations over 10 seconds (109,573 ops/s)

KEY FINDINGS
============

CPU Hotspots (hot-methods):
---------------------------
- java.util.Arrays.equals(Object[], Object[]): 12.90%
- java.lang.invoke.MethodHandle.asSpreader(int, Class, int): 9.68%  
- Multiple MethodHandle/invoke operations: ~20% total

Memory Allocation Hotspots (allocation-by-site):
-----------------------------------------------
1. java.lang.invoke.LambdaFormEditor.lambdaFormEditor(LambdaForm): 25.16%
2. java.lang.Class.getRecordComponents0(): 20.92%
3. java.lang.invoke.MethodType.makeImpl(Class, Class[], boolean): 19.99%
4. io.github.simbo1905.no.framework.WriteBufferImpl.<init>: 9.36%

ROOT CAUSE ANALYSIS
==================
The profiling data clearly shows reflection work happening during serialization:

1. **Record Component Resolution**: 20.92% allocation in getRecordComponents0() 
   indicates record introspection on every write operation

2. **Method Handle Creation**: 25.16% allocation in LambdaFormEditor + 19.99% in 
   MethodType.makeImpl shows method handle setup during serialization

3. **Dynamic Method Resolution**: MethodHandle.asSpreader calls indicate runtime
   method adaptation instead of cached prepared handles

Expected Behavior: All reflection work should happen once during RecordPickler 
construction, not during every serialize() call.

PERFORMANCE IMPACT
==================
Write Performance: 125,664 ops/s (should be 1M+ ops/s based on read performance)
Read Performance: 3,083,415 ops/s (11x faster than JDK - proves architecture works)
Round-trip: 117,023 ops/s (write bottleneck dominates)

The read performance proves NFP architecture is sound. The write slowdown is
purely due to reflection work not being properly cached.

RECOMMENDED FIXES
================

1. **Cache Record Components**: Move getRecordComponents() call to RecordPickler
   constructor, store results in instance fields

2. **Pre-build Method Handles**: Create and cache all MethodHandle instances
   during pickler construction, not during serialization

3. **Avoid Dynamic Method Resolution**: Replace asSpreader() calls with
   pre-built method handles optimized for exact parameter counts

4. **Verify Hot Path**: Audit serialize() method to ensure no reflection
   calls remain on the hot path

5. **Add Regression Test**: testPrimitiveWritePerformance() added to 
   MachineryTests to catch future regressions

VALIDATION APPROACH
==================
1. Fix reflection caching issues
2. Re-run WritePathProfiler to verify allocation patterns change
3. Confirm hot-methods no longer show reflection calls
4. Benchmark should show 5-10x write performance improvement
5. Target: >500k ops/s write performance (based on read performance scaling)

LESSONS LEARNED
===============
1. JFR allocation-by-site is excellent for finding hot path issues
2. Method handle allocation indicates reflection work happening at runtime
3. Always profile write and read paths separately
4. Performance regression tests prevent these issues from recurring
5. NFP architecture is sound - implementation just needs optimization

NEXT STEPS
==========
1. Implement reflection caching fixes
2. Re-profile to verify improvements  
3. Update benchmark results in results.njson
4. Document performance optimization in ANALYSIS.md
5. Consider adding performance monitoring to CI/CD pipeline

FILES CREATED
=============
- WritePathProfiler.java: Focused performance reproducer
- MachineryTests.testPrimitiveWritePerformance(): Regression test
- write-profile.jfr: JFR recording data
- This report: profiling-report.2025-05-31_1.txt

REFERENCES
==========
- PROFILING.md: Complete profiling methodology
- PrimitiveBenchmark.java: Original benchmark showing issue
- CLAUDE.md: Quick profiling reference section